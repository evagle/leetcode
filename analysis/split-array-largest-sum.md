## Split Array Largest Sum [ [sourcecode](../src/split-array-largest-sum.cpp) | [problem](https://leetcode.com/problems/split-array-largest-sum/) ]

##解法分析
给一个数组S，有n个元素，给定一个数m，将S分成m个连续子数组，使得m个子数组的和的最大值最小，求这个最大值

最开始错误的想法：
将S分成n个组，然后依次merge和最小的两个组，直到剩下m个组。这样是有bug的，
S=[9,3,6,9], m=2, 按照上面的思想就生成了=>[9,9,9]=>[18,9],
但是最优结果是[12,15],所以最优结果是15，而不是18.

正确解法：
首先遍历找到S中的最大值为x，这个是m=n的情况下的最大值，当m=1时，最大值为y=S所有的元素和。
因为m在1-n之间，所以结果肯定介于[x,y]之间。那就二分去找。
mid=(x+y)/2
然后检查子数组最大和是否小于mid

检查方法：基于贪心思想，从左到右，尽量保证接近mid,记录当前累加值，如果小于mid，继续加，否则重新开始一个新的组。如果还没扫描完，组数量已经到m了，说明没法分成m个组使得最大值不大于mid。否则就是能解决。

例如[9,3,6,9],x=9,y=27, mid=18,扫描到9+3+6=18，这个组不能再继续加，从下一个9开始一个新的组，然后结束，正好两个组。

如果mid能达到，y=mid,否则x=mid+1，直到x>=y时，x的值就是最终结果。

复杂度：
n<1000, 每个数最大值2^31,所以总和最大2^41，二分查找nlog(2^41)=41n，

##步骤或伪代码
