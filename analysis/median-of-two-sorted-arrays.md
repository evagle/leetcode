
##Median of Two Sorted Arrays [ [sourcecode](../src/MedianofTwoSortedArrays.cpp) | [problem](https://oj.leetcode.com/problems/median-of-two-sorted-arrays/) ]

##分析
题意很简单：给定两个已排序的数组，求两个数组合并之后的数组的中位数。如果是总个数是奇数个，那就是最中间的那个，如果是偶数个，那就求最中间的两个的平均值。 要求在O(lg(m+n))时间内求出。

#### 方法1：排序
如果不考虑时间空间限制，可以采用排序方法，将两个数组合并，然后排序，然后直接O(1)时间获得结果。
排序方法的选择。如果选择快速排序，复杂度是nlogn。但最优的是选择归并排序，此处只须用到归并排序的合并步骤。边合并边计数，到 m+n/2 就答案。时间复杂度O(m+n),空间复杂度O(1).

#### 方法2：找第K大数法
找中位数可以泛华为找第K大数，中位数就是第(m+n)/2+1大得数（奇数个数的情况）。下面讨论如何找第K大数。
核心思路是竟可能快的把第K+1以后的数全部排除，剩下K个数，那两个数组中最大的就是结果。如何排除呢？

1. 将数目较少的数组记为A数组  
2. 取A中得前p个数，B中前q个数，使得p+q=k+1. 其中，p=min(k/2+1,len(A)), q = k+1-p。这样的做法的好处是，尽量使得p和q相近。
3. 如果A[p-1] < B[q-1],说明B[q-1]肯定比第K大数大，因为A[0..p-1]和B[0..q-2]都小于B[q-1]，总共p+q-1=k个。
4. 将B[q-1...n]都去除，再从第一步1开始递归。
5. 反之，如果A[p-1] > B[q-1]，将A[p-1...m]都去除，从第一步1开始递归。
6. 如果相等，说明第K大和第K+1大的数相等，A[p-1] ，B[q-1]其中一个第K大，另一个第K+1大。直接返回A[p-1]或者B[q-1]。

现在考虑停止条件:

1. 当出现A[p-1] = B[q-1]时，直接返回结果。
2. 如果A数组（较短的数组）已经为空，那么返回B[k]
3. 如果m+n=k,m为A的长度，n为B的长度；说明所有的大于第k大数的都被剔除了，剩下前k大得数，返回最大值max(A[m-1],B[n-1])。

求解题目:题目需要求中位数，那么只需要另k=(m+n)/2+1,m+n为奇数；或者k1=(m+n)/2, k2=(m+n)/2+1, m+n为偶数。
   
#### 方法3，二分法
这个方法我没有用代码实现，只讲思路。
首先取A和B的中位数，设为i和j，如果A[i]<B[j]，那么说明B数组j之后的数都不可能是中位数，A数组i以前的数也不可能是中位数。那么我们取k=min(i,n-j）然后将A去掉前k位，B去掉后k位，相当于小于中位数的数和大于中位数的数各去掉了k个，那原数组的中位数和现在去掉2k个数的中位数还是一样的，然后递归，直到某个数组元素小于等于2个时停止。
如果有一个数组只剩下两个元素时，直接二分查找到这个数在另外一个数组的下标位置，分情况考虑下标是否小于k，就能得出结果。


##坑：
注意p的取值，p取值时需要考虑不能使得q大于B数组的长度。p如果取min(k/2,m)的时候，就会出现死循环。例子是A={1,2,2}, B={1,2,3}. 
	
	1. 第一次k=3， p=1，q=3，把B的最后一个数移除
	2. 第二次递归：A={1,2}, B={1,2,2}；k=3， p=1，q=3；将最后的B最后的2移除了。
	3. 然后再次递归：A=B={1，2}；k=3， p=1，q=3；结果B现在只有两个数，出错了。因为p取值的时候会有判断p=min(k/2,m),使得p不会超过m，但是q没有限制，所以需要让p=min(k/2+1,m),这样q无论如何都不会出现大于n的情况。
	
		证明如下:
		先考虑m<=k/2+1的情况，那p=m, m+n>=k+1(如果m+n==k满足终止条件就结束了) -> p+n>=k+1 -> k+1-q+n>=k+1 -> q<=n，符合条件。
		然后考虑m>k/2+1的情况，p = k/2+1,如果k为奇数，q=k/2, 因为程序始终保证A是较少的数组，所以n>=m>k/2+1>k/2=q；如果k是偶数，q = k/2-1 < k/2+1<m<=n。所以无论如何q<n.
		综上，若p=min(k/2+1, m) ,则满足q<n.
		


